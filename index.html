<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ç³–è±†äºº - Jelly Man</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    #gameContainer {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #gameCanvas {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      border-radius: 8px;
      box-shadow: 0 0 40px rgba(0, 200, 255, 0.3);
    }

    #ui {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      font-size: 18px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      z-index: 10;
    }

    #soundToggle {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 16px;
      z-index: 10;
      transition: background 0.3s;
    }

    #soundToggle:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    #instructions {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.7);
      font-size: 14px;
      text-align: center;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
      <div id="playerCount">ç©å®¶: <span id="count">0</span></div>
      <div id="roundInfo">å›åˆ: <span id="round">1</span></div>
      <div id="levelSelect" style="margin-top: 10px;">
        <select id="modeSelect" style="padding: 5px; font-size: 14px; border-radius: 5px; margin-bottom: 5px;">
          <option value="1">å•äººæ¨¡å¼ (vs AI)</option>
          <option value="2">åŒäººæ¨¡å¼ (P1: WASD+ç©ºæ ¼, P2: æ–¹å‘é”®+Enter)</option>
        </select><br>
        <select id="levelSelectDropdown" style="padding: 5px; font-size: 14px; border-radius: 5px;">
          <option value="1">ç¬¬1å…³: è‰è“æ´¾å¯¹</option>
          <option value="2">ç¬¬2å…³: å†°å†»æ‚¬å´–</option>
          <option value="3">ç¬¬3å…³: æ—‹è½¬é£æš´</option>
          <option value="4">ç¬¬4å…³: éšœç¢è¿·å®«</option>
          <option value="5">ç¬¬5å…³: é—ªç”µå†²åˆº</option>
          <option value="6">ç¬¬6å…³: é©¬æˆå›¢</option>
          <option value="7">ç¬¬7å…³: å½©è™¹æ¡¥</option>
          <option value="8">ç¬¬8å…³: ç«ç„°åœ°ç‹±</option>
          <option value="9">ç¬¬9å…³: æ˜Ÿå…‰å¤§é“</option>
          <option value="10">ç¬¬10å…³: æœ€ç»ˆå†³æˆ˜</option>
        </select>
      </div>
    </div>
    <button id="soundToggle">ğŸ”Š éŸ³æ•ˆ: å¼€</button>
    <div id="instructions">æ–¹å‘é”®/WASD ç§»åŠ¨ | ç©ºæ ¼ è·³è·ƒ | G æŠ“å– | æ”¶é›†é“å…·å˜å¼ºï¼</div>
  </div>

  <script>
    // ==================== å¸¸é‡é…ç½® ====================
    const CONFIG = {
      LOGICAL_WIDTH: 1920,
      LOGICAL_HEIGHT: 1080,
      PLAYER_COUNT: 12,
      PLAYER_RADIUS: 35,
      MOVE_SPEED: 8,
      JUMP_FORCE: -18,
      GRAVITY: 0.8,
      FRICTION: 0.88,
      BOUNCE: 0.4,
      PLATFORM_WIDTH: 1600,
      PLATFORM_HEIGHT: 200,
      OBSTACLE_COUNT: 5,
      ROUND_TIME: 60,
      COUNTDOWN_TIME: 3
    };

    const COLORS = {
      BACKGROUND: '#1a1a2e',
      PLATFORM: '#4a4a6a',
      PLATFORM_EDGE: '#6a6a8a',
      PLAYER_COLORS: [
        '#FF6B6B', '#9400D3', '#45B7D1', '#96CEB4',
        '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F',
        '#BB8FCE', '#85C1E9', '#F8B500', '#00CED1'
      ],
      TEXT: '#FFFFFF',
      TEXT_SHADOW: 'rgba(0, 0, 0, 0.5)'
    };



    // ==================== é“å…·é…ç½® ====================
    const POWERUPS = [
      { type: 'speed', name: 'åŠ é€Ÿ', duration: 5000, color: '#FFD700' },
      { type: 'jump', name: 'è·³è·ƒå¼ºåŒ–', duration: 5000, color: '#00FF00' },
      { type: 'size', name: 'å˜å¤§', duration: 5000, color: '#FF4500' },
      { type: 'grab', name: 'æŠ“å–', duration: 8000, color: '#9400D3' }
    ];

    // ==================== å…³å¡é…ç½® ====================
    const LEVELS = [
      { name: 'ç¬¬1å…³: è‰è“æ´¾å¯¹', time: 60, obstacles: [
        { type: 'spinner', x: 600, y: 350 }, { type: 'spinner', x: 1320, y: 350 },
        { type: 'swing', x: 760, y: 450 }, { type: 'swing', x: 960, y: 450 }, { type: 'swing', x: 1160, y: 450 }
      ]},
      { name: 'ç¬¬2å…³: å†°å†»æ‚¬å´–', time: 55, obstacles: [
        { type: 'spinner', x: 500, y: 300 }, { type: 'spinner', x: 960, y: 300 }, { type: 'spinner', x: 1420, y: 300 },
        { type: 'swing', x: 700, y: 450 }, { type: 'swing', x: 1220, y: 450 }
      ]},
      { name: 'ç¬¬3å…³: æ—‹è½¬é£æš´', time: 50, obstacles: [
        { type: 'spinner', x: 400, y: 250 }, { type: 'spinner', x: 700, y: 250 }, { type: 'spinner', x: 1000, y: 250 },
        { type: 'spinner', x: 1300, y: 250 }, { type: 'spinner', x: 1600, y: 250 },
        { type: 'swing', x: 550, y: 450 }, { type: 'swing', x: 850, y: 450 }, { type: 'swing', x: 1150, y: 450 }, { type: 'swing', x: 1450, y: 450 }
      ]},
      { name: 'ç¬¬4å…³: éšœç¢è¿·å®«', time: 55, obstacles: [
        { type: 'spinner', x: 600, y: 350 }, { type: 'spinner', x: 1320, y: 350 },
        { type: 'swing', x: 400, y: 400 }, { type: 'swing', x: 600, y: 500 }, { type: 'swing', x: 800, y: 400 },
        { type: 'swing', x: 1000, y: 500 }, { type: 'swing', x: 1200, y: 400 }, { type: 'swing', x: 1400, y: 500 }
      ]},
      { name: 'ç¬¬5å…³: é—ªç”µå†²åˆº', time: 45, obstacles: [
        { type: 'spinner', x: 480, y: 280 }, { type: 'spinner', x: 720, y: 280 }, { type: 'spinner', x: 960, y: 280 },
        { type: 'spinner', x: 1200, y: 280 }, { type: 'spinner', x: 1440, y: 280 },
        { type: 'swing', x: 600, y: 420 }, { type: 'swing', x: 840, y: 420 }, { type: 'swing', x: 1080, y: 420 }, { type: 'swing', x: 1320, y: 420 }
      ]},
      { name: 'ç¬¬6å…³: é©¬æˆå›¢', time: 50, obstacles: [
        { type: 'spinner', x: 500, y: 200 }, { type: 'spinner', x: 960, y: 200 }, { type: 'spinner', x: 1420, y: 200 },
        { type: 'swing', x: 350, y: 350 }, { type: 'swing', x: 550, y: 450 }, { type: 'swing', x: 750, y: 350 },
        { type: 'swing', x: 1170, y: 350 }, { type: 'swing', x: 1370, y: 450 }, { type: 'swing', x: 1570, y: 350 }
      ]},
      { name: 'ç¬¬7å…³: å½©è™¹æ¡¥', time: 55, obstacles: [
        { type: 'spinner', x: 600, y: 300 }, { type: 'spinner', x: 960, y: 300 }, { type: 'spinner', x: 1320, y: 300 },
        { type: 'swing', x: 400, y: 400 }, { type: 'swing', x: 600, y: 500 }, { type: 'swing', x: 800, y: 400 },
        { type: 'swing', x: 1000, y: 500 }, { type: 'swing', x: 1200, y: 400 }, { type: 'swing', x: 1400, y: 500 }
      ]},
      { name: 'ç¬¬8å…³: ç«ç„°åœ°ç‹±', time: 45, obstacles: [
        { type: 'spinner', x: 480, y: 250 }, { type: 'spinner', x: 800, y: 250 }, { type: 'spinner', x: 1120, y: 250 }, { type: 'spinner', x: 1440, y: 250 },
        { type: 'swing', x: 640, y: 400 }, { type: 'swing', x: 960, y: 400 }, { type: 'swing', x: 1280, y: 400 }
      ]},
      { name: 'ç¬¬9å…³: æ˜Ÿå…‰å¤§é“', time: 50, obstacles: [
        { type: 'spinner', x: 400, y: 280 }, { type: 'spinner', x: 680, y: 280 }, { type: 'spinner', x: 960, y: 280 },
        { type: 'spinner', x: 1240, y: 280 }, { type: 'spinner', x: 1520, y: 280 },
        { type: 'swing', x: 540, y: 450 }, { type: 'swing', x: 820, y: 450 }, { type: 'swing', x: 1100, y: 450 }, { type: 'swing', x: 1380, y: 450 }
      ]},
      { name: 'ç¬¬10å…³: æœ€ç»ˆå†³æˆ˜', time: 60, obstacles: [
        { type: 'spinner', x: 320, y: 200 }, { type: 'spinner', x: 580, y: 200 }, { type: 'spinner', x: 840, y: 200 },
        { type: 'spinner', x: 1100, y: 200 }, { type: 'spinner', x: 1360, y: 200 }, { type: 'spinner', x: 1620, y: 200 },
        { type: 'swing', x: 450, y: 400 }, { type: 'swing', x: 710, y: 400 }, { type: 'swing', x: 970, y: 400 },
        { type: 'swing', x: 1230, y: 400 }, { type: 'swing', x: 1490, y: 400 }
      ]}
    ];

    const GameState = {
      MENU: 'menu',
      COUNTDOWN: 'countdown',
      PLAYING: 'playing',
      ROUND_END: 'round_end',
      GAME_OVER: 'game_over'
    };

    // ==================== éŸ³æ•ˆç³»ç»Ÿ ====================
    class SoundManager {
      constructor() {
        this.audioContext = null;
        this.enabled = true;
        this.initialized = false;
      }

      init() {
        if (this.initialized) return;
        try {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          this.initialized = true;
        } catch (e) {
          console.warn('Web Audio API ä¸æ”¯æŒ');
        }
      }

      playTone(frequency, duration, type = 'sine', volume = 0.3) {
        if (!this.enabled || !this.audioContext) return;
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.frequency.value = frequency;
        oscillator.type = type;
        
        gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
        
        oscillator.start();
        oscillator.stop(this.audioContext.currentTime + duration);
      }

      playJump() {
        this.playTone(400, 0.15, 'sine', 0.2);
        setTimeout(() => this.playTone(600, 0.1, 'sine', 0.15), 50);
      }

      playLand() {
        this.playTone(150, 0.1, 'triangle', 0.3);
      }

      playHit() {
        this.playTone(200, 0.15, 'square', 0.2);
      }

      playFall() {
        this.playTone(300, 0.3, 'sawtooth', 0.25);
        setTimeout(() => this.playTone(200, 0.3, 'sawtooth', 0.2), 150);
        setTimeout(() => this.playTone(100, 0.4, 'sawtooth', 0.15), 300);
      }

      playWin() {
        const notes = [523, 659, 784, 1047];
        notes.forEach((note, i) => {
          setTimeout(() => this.playTone(note, 0.3, 'sine', 0.25), i * 150);
        });
      }

      playCountdown() {
        this.playTone(880, 0.1, 'sine', 0.2);
      }

      playButton() {
        this.playTone(600, 0.08, 'sine', 0.15);
      }

      toggle() {
        this.enabled = !this.enabled;
        return this.enabled;
      }
    }

    // ==================== ç³–è±†äººç©å®¶ç±» ====================
    class JellyPlayer {
      constructor(x, y, color, isPlayer = false) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.color = color;
        this.radius = CONFIG.PLAYER_RADIUS;
        this.isPlayer = isPlayer;
        this.isAlive = true;
        this.wobble = Math.random() * Math.PI * 2;
        this.wobbleSpeed = 0.15;
        this.scaleX = 1;
        this.scaleY = 1;
        this.targetX = x;
        this.targetY = y;
        this.onGround = false;
        this.expression = 'normal';
        this.powerups = { speed: 0, jump: 0, size: 0, grab: 0 };
        this.isGrabbed = false;
        this.grabbedBy = null;
        this.grabCooldown = 0;
        this.playerId = 0;
      }
      
      applyPowerup(type) {
        this.powerups[type] = Date.now() + POWERUPS.find(p => p.type === type).duration;
      }
      
      updatePowerups() {
        const now = Date.now();
        for (const key in this.powerups) {
          if (this.powerups[key] && this.powerups[key] < now) {
            this.powerups[key] = 0;
          }
        }
      }

      update(deltaTime, platform, obstacles, players) {
        if (!this.isAlive) return;

        // æ›´æ–°é“å…·çŠ¶æ€
        this.updatePowerups();
        
        // å¦‚æœè¢«æŠ“å–
        if (this.isGrabbed && this.grabbedBy) {
          this.x = this.grabbedBy.x + (this.x > this.grabbedBy.x ? 30 : -30);
          this.y = this.grabbedBy.y - 20;
          this.vx = 0;
          this.vy = 0;
          return;
        }

        // æœå†»æ‘†åŠ¨åŠ¨ç”»
        this.wobble += this.wobbleSpeed * deltaTime;
        const wobbleAmount = 0.08;
        this.scaleX = 1 + Math.sin(this.wobble) * wobbleAmount;
        this.scaleY = 1 - Math.sin(this.wobble) * wobbleAmount;

        // å¦‚æœæ˜¯ç©å®¶ï¼Œå“åº”è¾“å…¥
        if (this.isPlayer) {
          this.handleInput(players);
        } else {
          // AI è¡Œä¸º
          this.handleAI(platform, obstacles, players);
        }

        // åº”ç”¨é‡åŠ›
        this.vy += CONFIG.GRAVITY;

        // åº”ç”¨æ‘©æ“¦åŠ›
        this.vx *= CONFIG.FRICTION;

        // æ›´æ–°ä½ç½®
        this.x += this.vx;
        this.y += this.vy;

        // å¹³å°ç¢°æ’
        this.handlePlatformCollision(platform);

        // éšœç¢ç‰©ç¢°æ’
        this.handleObstacleCollision(obstacles);

        // ç©å®¶é—´ç¢°æ’
        this.handlePlayerCollision(players);

        // æ›´æ–°è¡¨æƒ…
        this.updateExpression();

        // æ£€æŸ¥æ˜¯å¦æ‰å‡ºå¹³å°
        if (this.y > CONFIG.LOGICAL_HEIGHT + 100) {
          this.eliminate();
        }
      }

      handleInput(players) {
        // åº”ç”¨é“å…·æ•ˆæœ
        let currentMoveSpeed = CONFIG.MOVE_SPEED;
        let currentJumpForce = CONFIG.JUMP_FORCE;
        let currentSize = 1;
        
        if (this.powerups.speed) currentMoveSpeed *= 1.8;
        if (this.powerups.jump) currentJumpForce *= 1.5;
        if (this.powerups.size) currentSize = 1.5;
        
        // æ ¹æ®ç©å®¶IDé€‰æ‹©æ§åˆ¶æ–¹æ¡ˆ
        if (this.playerId === 1) {
          // P1: WASD + ç©ºæ ¼
          if (window.keys.KeyA) this.vx -= 1.5;
          if (window.keys.KeyD) this.vx += 1.5;
          if (window.keys.KeyW && this.onGround) {
            this.vy = currentJumpForce;
            this.onGround = false;
            soundManager.playJump();
          }
        } else if (this.playerId === 2) {
          // P2: æ–¹å‘é”® + Enter
          if (window.keys.ArrowLeft) this.vx -= 1.5;
          if (window.keys.ArrowRight) this.vx += 1.5;
          if ((window.keys.Enter || window.keys.ArrowUp) && this.onGround) {
            this.vy = currentJumpForce;
            this.onGround = false;
            soundManager.playJump();
          }
        } else {
          // å•äººæ¨¡å¼é»˜è®¤æ§åˆ¶
          if (window.keys.ArrowLeft || window.keys.KeyA) this.vx -= 1.2;
          if (window.keys.ArrowRight || window.keys.KeyD) this.vx += 1.2;
          if ((window.keys.Space || window.keys.ArrowUp || window.keys.KeyW) && this.onGround) {
            this.vy = currentJumpForce;
            this.onGround = false;
            soundManager.playJump();
          }
        }
        
        // æŠ“å–åŠŸèƒ½ (æŒ‰Gé”®)
        if ((window.keys.KeyG || window.keys.KeyE) && this.powerups.grab) {
          this.tryGrab(players);
        }

        // é™åˆ¶é€Ÿåº¦
        this.vx = Math.max(-currentMoveSpeed, Math.min(currentMoveSpeed, this.vx));
        
        // åº”ç”¨å¤§å°
        this.scaleX = (1 + Math.sin(this.wobble) * 0.08) * currentSize;
        this.scaleY = (1 - Math.sin(this.wobble) * 0.08) * currentSize;
      }
      
      tryGrab(players) {
        if (this.grabCooldown > 0) return;
        
        for (const other of players) {
          if (other === this || !other.isAlive || other.isGrabbed) continue;
          
          const dx = other.x - this.x;
          const dy = other.y - this.y;
          const dist = Math.hypot(dx, dy);
          
          if (dist < this.radius * 3) {
            other.isGrabbed = true;
            other.grabbedBy = this;
            this.grabCooldown = 30;
            soundManager.playHit();
            
            setTimeout(() => {
              if (other.isGrabbed) {
                other.isGrabbed = false;
                other.grabbedBy = null;
                other.vx = this.vx * 2;
                other.vy = -10;
              }
            }, 1500);
            break;
          }
        }
      }

      handleAI(platform, obstacles, players) {
        // ç®€å•çš„ AI è¡Œä¸º
        const alivePlayers = players.filter(p => p.isAlive);
        
        // å¯»æ‰¾ç›®æ ‡ä½ç½®
        if (Math.random() < 0.02) {
          // éšæœºç§»åŠ¨
          this.targetX = platform.x - platform.width/2 + Math.random() * platform.width;
          this.targetY = platform.y - platform.height/2 - 50;
        }

        // å‘ç›®æ ‡ç§»åŠ¨
        const dx = this.targetX - this.x;
        if (Math.abs(dx) > 20) {
          this.vx += dx > 0 ? 0.5 : -0.5;
        }

        // è·³è·ƒä»¥é¿å¼€éšœç¢ç‰©
        for (const obs of obstacles) {
          const dist = Math.hypot(this.x - obs.x, this.y - obs.y);
          if (dist < 150 && this.onGround) {
            this.vy = CONFIG.JUMP_FORCE;
            this.onGround = false;
          }
        }

        // é™åˆ¶é€Ÿåº¦
        this.vx = Math.max(-CONFIG.MOVE_SPEED * 0.7, Math.min(CONFIG.MOVE_SPEED * 0.7, this.vx));

        // éšæœºè·³è·ƒ
        if (this.onGround && Math.random() < 0.005) {
          this.vy = CONFIG.JUMP_FORCE;
          this.onGround = false;
        }
      }

      handlePlatformCollision(platform) {
        const platTop = platform.y - platform.height / 2;
        const platLeft = platform.x - platform.width / 2;
        const platRight = platform.x + platform.width / 2;

        // æ£€æµ‹æ˜¯å¦åœ¨å¹³å°èŒƒå›´å†…
        if (this.x > platLeft && this.x < platRight) {
          // ä»ä¸Šæ–¹è½ä¸‹
          if (this.y + this.radius > platTop && 
              this.y - this.radius < platTop + 20 &&
              this.vy > 0) {
            this.y = platTop - this.radius;
            if (this.vy > 5) {
              soundManager.playLand();
            }
            this.vy = -this.vy * CONFIG.BOUNCE;
            if (Math.abs(this.vy) < 2) {
              this.vy = 0;
              this.onGround = true;
            }
          }
        }
        
        // å·¦å³æ˜¯æ‚¬å´–ï¼Œå¯ä»¥æ‰ä¸‹å» - ä¸åŠ è¾¹ç•Œ
        
        // é¡¶éƒ¨å¤©ç©ºè¾¹ç•Œï¼ˆé˜²æ­¢é£å¤ªé«˜ï¼‰
        if (this.y < 100) {
          this.y = 100;
          this.vy = Math.abs(this.vy) * 0.3;
        }
      }

      handleObstacleCollision(obstacles) {
        for (const obs of obstacles) {
          const dx = this.x - obs.x;
          const dy = this.y - obs.y;
          const dist = Math.hypot(dx, dy);
          const minDist = this.radius + obs.radius;

          if (dist < minDist) {
            // ç¢°æ’å“åº”
            const angle = Math.atan2(dy, dx);
            const pushForce = 8;
            this.vx += Math.cos(angle) * pushForce;
            this.vy += Math.sin(angle) * pushForce;
            soundManager.playHit();
          }
        }
      }

      handlePlayerCollision(players) {
        for (const other of players) {
          if (other === this || !other.isAlive) continue;

          const dx = this.x - other.x;
          const dy = this.y - other.y;
          const dist = Math.hypot(dx, dy);
          const minDist = this.radius + other.radius;

          if (dist < minDist && dist > 0) {
            // çŒ›çƒˆæ¨æŒ¤ï¼
            const overlap = minDist - dist;
            const angle = Math.atan2(dy, dx);
            
            // å¤§å¹…å¢åŠ æŒ¤å‹åŠ›åº¦
            const pushForce = 3.0;
            const pushX = Math.cos(angle) * overlap * pushForce;
            const pushY = Math.sin(angle) * overlap * pushForce;

            this.x += pushX;
            this.y += pushY;
            other.x -= pushX;
            other.y -= pushY;

            // æ’å‡»é€Ÿåº¦åŠ æˆ
            const impactSpeed = Math.abs(this.vx - other.vx) + Math.abs(this.vy - other.vy);
            const bounceBonus = 1.5;
            
            this.vx += Math.cos(angle) * impactSpeed * bounceBonus;
            this.vy += Math.sin(angle) * impactSpeed * bounceBonus;
            other.vx -= Math.cos(angle) * impactSpeed * bounceBonus;
            other.vy -= Math.sin(angle) * impactSpeed * bounceBonus;
            
            // ç¢°æ’éŸ³æ•ˆ
            if (impactSpeed > 5) {
              soundManager.playHit();
            }
          }
        }
      }

      updateExpression() {
        if (!this.isAlive) {
          this.expression = 'dead';
        } else if (Math.abs(this.vy) > 8) {
          this.expression = 'surprised';
        } else if (Math.abs(this.vx) > CONFIG.MOVE_SPEED * 0.8) {
          this.expression = 'excited';
        } else {
          this.expression = 'normal';
        }
      }

      eliminate() {
        this.isAlive = false;
        soundManager.playFall();
      }

      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.scaleX, this.scaleY);

        // ç»˜åˆ¶èº«ä½“ï¼ˆæœå†»å½¢çŠ¶ï¼‰
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        
        // æ¸å˜å¡«å……
        const gradient = ctx.createRadialGradient(
          -this.radius * 0.3, -this.radius * 0.3, 0,
          0, 0, this.radius
        );
        gradient.addColorStop(0, this.lightenColor(this.color, 40));
        gradient.addColorStop(0.7, this.color);
        gradient.addColorStop(1, this.darkenColor(this.color, 20));
        ctx.fillStyle = gradient;
        ctx.fill();

        // èº«ä½“è½®å»“
        ctx.strokeStyle = this.darkenColor(this.color, 30);
        ctx.lineWidth = 3;
        ctx.stroke();

        // ç»˜åˆ¶çœ¼ç›
        this.drawEyes(ctx);

        // ç©å®¶æ ‡è¯†
        if (this.isAlive && this.playerId > 0) {
          this.drawPlayerIndicator(ctx);
        }

        ctx.restore();
      }

      drawPlayerIndicator(ctx) {
        const starY = -this.radius - 25;
        const label = this.playerId === 1 ? 'P1' : 'P2';
        const labelColor = this.playerId === 1 ? '#FF6B6B' : '#9400D3';
        
        ctx.save();
        ctx.translate(0, starY);
        
        // é—ªçƒæ˜Ÿæ˜Ÿ
        const pulse = Math.sin(Date.now() / 150) * 0.2 + 1;
        ctx.scale(pulse, pulse);
        
        ctx.beginPath();
        const spikes = 5;
        const outerRadius = 10;
        const innerRadius = 4;
        
        for (let i = 0; i < spikes * 2; i++) {
          const r = i % 2 === 0 ? outerRadius : innerRadius;
          const angle = (Math.PI / spikes) * i - Math.PI / 2;
          const x = Math.cos(angle) * r;
          const y = Math.sin(angle) * r;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fillStyle = '#FFD700';
        ctx.fill();
        ctx.strokeStyle = '#FFA500';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.restore();
        
        // P1/P2æ–‡å­—
        ctx.save();
        ctx.translate(0, starY - 18);
        ctx.font = 'bold 14px Microsoft YaHei';
        ctx.fillStyle = labelColor;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.textAlign = 'center';
        ctx.strokeText(label, 0, 0);
        ctx.fillText(label, 0, 0);
        ctx.restore();
      }

      drawEyes(ctx) {
        const eyeOffsetX = 12;
        const eyeOffsetY = -5;
        const eyeRadius = 10;
        const pupilRadius = 5;

        // æ ¹æ®é€Ÿåº¦è®¡ç®—è§†çº¿åç§»
        let lookX = this.vx * 1.5;
        let lookY = this.vy * 0.5;

        if (this.expression === 'surprised') {
          lookY = -5;
        } else if (this.expression === 'excited') {
          lookX = this.vx > 0 ? 3 : -3;
        }

        // å·¦çœ¼
        ctx.beginPath();
        ctx.arc(-eyeOffsetX, eyeOffsetY, eyeRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.stroke();

        // å·¦ç³å­”
        ctx.beginPath();
        ctx.arc(-eyeOffsetX + lookX, eyeOffsetY + lookY, pupilRadius, 0, Math.PI * 2);
        ctx.fillStyle = '#333';
        ctx.fill();

        // å³çœ¼
        ctx.beginPath();
        ctx.arc(eyeOffsetX, eyeOffsetY, eyeRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.stroke();

        // å³ç³å­”
        ctx.beginPath();
        ctx.arc(eyeOffsetX + lookX, eyeOffsetY + lookY, pupilRadius, 0, Math.PI * 2);
        ctx.fillStyle = '#333';
        ctx.fill();

        // è¡¨æƒ…
        if (this.expression === 'surprised') {
          // æƒŠè®¶ - å¼ å¤§å˜´å·´
          ctx.beginPath();
          ctx.arc(0, 12, 8, 0, Math.PI * 2);
          ctx.fillStyle = '#FF6B6B';
          ctx.fill();
        } else if (this.expression === 'dead') {
          // æ­»äº¡ - X çœ¼ç›
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 2;
          
          // å·¦çœ¼ X
          ctx.beginPath();
          ctx.moveTo(-eyeOffsetX - 5, eyeOffsetY - 5);
          ctx.lineTo(-eyeOffsetX + 5, eyeOffsetY + 5);
          ctx.moveTo(-eyeOffsetX + 5, eyeOffsetY - 5);
          ctx.lineTo(-eyeOffsetX - 5, eyeOffsetY + 5);
          ctx.stroke();

          // å³çœ¼ X
          ctx.beginPath();
          ctx.moveTo(eyeOffsetX - 5, eyeOffsetY - 5);
          ctx.lineTo(eyeOffsetX + 5, eyeOffsetY + 5);
          ctx.moveTo(eyeOffsetX + 5, eyeOffsetY - 5);
          ctx.lineTo(eyeOffsetX - 5, eyeOffsetY + 5);
          ctx.stroke();
        }
      }

      lightenColor(color, percent) {
        const num = parseInt(color.replace('#', ''), 16);
        const amt = Math.round(2.55 * percent);
        const R = Math.min(255, (num >> 16) + amt);
        const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
        const B = Math.min(255, (num & 0x0000FF) + amt);
        return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
      }

      darkenColor(color, percent) {
        const num = parseInt(color.replace('#', ''), 16);
        const amt = Math.round(2.55 * percent);
        const R = Math.max(0, (num >> 16) - amt);
        const G = Math.max(0, ((num >> 8) & 0x00FF) - amt);
        const B = Math.max(0, (num & 0x0000FF) - amt);
        return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
      }
    }

    // ==================== é“å…·ç±» ====================
    class PowerupItem {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.powerup = POWERUPS.find(p => p.type === type);
        this.radius = 25;
        this.collected = false;
        this.pulse = Math.random() * Math.PI * 2;
      }
      
      update(deltaTime) {
        this.pulse += 0.1 * deltaTime;
      }
      
      draw(ctx) {
        if (this.collected) return;
        
        const pulse = Math.sin(this.pulse) * 0.2 + 1;
        const r = this.radius * pulse;
        
        ctx.save();
        ctx.translate(this.x, this.y);
        
        ctx.shadowColor = this.powerup.color;
        ctx.shadowBlur = 20;
        
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.fillStyle = this.powerup.color;
        ctx.fill();
        
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        ctx.restore();
      }
      
      checkCollision(player) {
        if (this.collected) return false;
        
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.hypot(dx, dy);
        
        if (dist < player.radius + this.radius) {
          this.collected = true;
          player.applyPowerup(this.type);
          return true;
        }
        return false;
      }
    }

    // ==================== éšœç¢ç‰©ç±» ====================
    class Obstacle {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.angle = 0;
        
        if (type === 'spinner') {
          this.radius = 60;
          this.rotationSpeed = 0.03;
        } else if (type === 'swing') {
          this.radius = 40;
          this.swingAngle = 0;
          this.swingSpeed = 0.05;
          this.swingAmplitude = 150;
        }
      }

      update(deltaTime) {
        if (this.type === 'spinner') {
          this.angle += this.rotationSpeed * deltaTime;
        } else if (this.type === 'swing') {
          this.swingAngle += this.swingSpeed * deltaTime;
          this.y = 450 + Math.sin(this.swingAngle) * this.swingAmplitude;
        }
      }

      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);

        if (this.type === 'spinner') {
          ctx.rotate(this.angle);
          
          // ç»˜åˆ¶æ—‹è½¬é£è½¦
          const armCount = 4;
          for (let i = 0; i < armCount; i++) {
            ctx.save();
            ctx.rotate((Math.PI * 2 / armCount) * i);
            
            // æ‰‹è‡‚
            ctx.fillStyle = '#FF6B6B';
            ctx.fillRect(-10, -this.radius, 20, this.radius * 1.5);
            
            // æœ«ç«¯çƒ
            ctx.beginPath();
            ctx.arc(0, -this.radius, 25, 0, Math.PI * 2);
            ctx.fillStyle = '#FF6B6B';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            ctx.restore();
          }

          // ä¸­å¿ƒ
          ctx.beginPath();
          ctx.arc(0, 0, 20, 0, Math.PI * 2);
          ctx.fillStyle = '#fff';
          ctx.fill();

        } else if (this.type === 'swing') {
          // ç»˜åˆ¶æ‘†åŠ¨çƒ
          ctx.beginPath();
          ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
          const gradient = ctx.createRadialGradient(-10, -10, 0, 0, 0, this.radius);
          gradient.addColorStop(0, '#FFE66D');
          gradient.addColorStop(1, '#F7B731');
          ctx.fillStyle = gradient;
          ctx.fill();
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 3;
          ctx.stroke();

          // ç»³å­
          ctx.beginPath();
          ctx.moveTo(0, -this.radius);
          ctx.lineTo(0, -this.y + 300);
          ctx.strokeStyle = '#888';
          ctx.lineWidth = 4;
          ctx.stroke();
        }

        ctx.restore();
      }
    }

    // ==================== æ¸¸æˆä¸»ç±» ====================
    class Game {
      constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.state = GameState.MENU;
        this.players = [];
        this.obstacles = [];
        this.platform = null;
        
        // è¯»å–é€‰ä¸­çš„å…³å¡
        const selectedLevel = parseInt(document.getElementById('levelSelectDropdown').value) || 1;
        this.round = selectedLevel;
        
        this.timeLeft = CONFIG.ROUND_TIME;
        this.countdown = CONFIG.COUNTDOWN_TIME;
        this.lastTime = 0;
        
        this.initCanvas();
        this.initPlatform();
        this.initObstacles();
        this.initInput();
        
        // å¯åŠ¨æ¸¸æˆå¾ªç¯
        this.gameLoop(0);
      }

      initCanvas() {
        const dpr = window.devicePixelRatio || 1;
        this.canvas.width = CONFIG.LOGICAL_WIDTH * dpr;
        this.canvas.height = CONFIG.LOGICAL_HEIGHT * dpr;
        this.ctx.scale(dpr, dpr);
        this.canvas.style.width = CONFIG.LOGICAL_WIDTH + 'px';
        this.canvas.style.height = CONFIG.LOGICAL_HEIGHT + 'px';
      }

      initPlatform() {
        this.platform = {
          x: CONFIG.LOGICAL_WIDTH / 2,
          y: CONFIG.LOGICAL_HEIGHT - 200,
          width: CONFIG.PLATFORM_WIDTH,
          height: CONFIG.PLATFORM_HEIGHT
        };
      }

      initObstacles() {
        this.obstacles = [];
        this.powerupItems = [];
        
        // è·å–å½“å‰å…³å¡é…ç½®
        const levelIndex = Math.min(this.round - 1, LEVELS.length - 1);
        const level = LEVELS[levelIndex];
        
        // è®¾ç½®å…³å¡æ—¶é—´
        CONFIG.ROUND_TIME = level.time;
        this.levelName = level.name;
        
        // æ ¹æ®å…³å¡é…ç½®æ·»åŠ éšœç¢ç‰©
        for (const obs of level.obstacles) {
          this.obstacles.push(new Obstacle(obs.x, obs.y, obs.type));
        }
        
        // æ·»åŠ é“å…·
        const powerupTypes = ['speed', 'jump', 'size', 'grab'];
        const numPowerups = 2 + Math.floor(Math.random() * 3);
        for (let i = 0; i < numPowerups; i++) {
          const type = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
          const x = CONFIG.PLATFORM_WIDTH/2 - 600 + Math.random() * 1200;
          const y = CONFIG.LOGICAL_HEIGHT - 350;
          this.powerupItems.push(new PowerupItem(x, y, type));
        }
      }

      initInput() {
        window.keys = {};
        
        window.addEventListener('keydown', (e) => {
          window.keys[e.code] = true;
          
          // åˆå§‹åŒ–éŸ³æ•ˆï¼ˆæµè§ˆå™¨ç­–ç•¥è¦æ±‚ç”¨æˆ·äº¤äº’ï¼‰
          soundManager.init();
          
          if (this.state === GameState.MENU ||
              this.state === GameState.GAME_OVER) {
            this.round = 1;
            this.startGame();
          } else if (this.state === GameState.ROUND_END) {
            // ç»§ç»­ä¸‹ä¸€å…³
            this.startNextLevel();
          }
        });

        window.addEventListener('keyup', (e) => {
          window.keys[e.code] = false;
        });

        // éŸ³æ•ˆå¼€å…³
        document.getElementById('soundToggle').addEventListener('click', () => {
          soundManager.init();
          const enabled = soundManager.toggle();
          document.getElementById('soundToggle').textContent = 
            enabled ? 'ğŸ”Š éŸ³æ•ˆ: å¼€' : 'ğŸ”‡ éŸ³æ•ˆ: å…³';
          soundManager.playButton();
        });
      }

      startGame(continueNextLevel = false) {
        // é‡æ–°åˆå§‹åŒ–å…³å¡
        const selectedLevel = parseInt(document.getElementById('levelSelectDropdown').value) || 1;
        this.round = selectedLevel;
        this.initObstacles();
        
        this.players = [];
        
        // è·å–æ¸¸æˆæ¨¡å¼
        const gameMode = parseInt(document.getElementById('modeSelect').value) || 1;
        
        // åˆ›å»ºç©å®¶
        if (gameMode === 2) {
          // åŒäººæ¨¡å¼ï¼š2ä¸ªç©å®¶ + 10ä¸ªAI
          for (let i = 0; i < 2; i++) {
            const x = this.platform.x - 200 + i * 400;
            const y = this.platform.y - this.platform.height/2 - 100;
            const player = new JellyPlayer(
              x, y, 
              i === 0 ? '#FF6B6B' : '#9400D3',
              true
            );
            player.playerId = i + 1;
            this.players.push(player);
          }
          // æ·»åŠ 10ä¸ªAI
          for (let i = 0; i < 10; i++) {
            const x = this.platform.x - this.platform.width/2 + 200 + i * 120;
            const y = this.platform.y - this.platform.height/2 - 100;
            const player = new JellyPlayer(
              x, y, 
              COLORS.PLAYER_COLORS[(i + 2) % COLORS.PLAYER_COLORS.length],
              false
            );
            this.players.push(player);
          }
        } else {
          // å•äººæ¨¡å¼ï¼š1ä¸ªç©å®¶ + 11ä¸ªAI
          for (let i = 0; i < CONFIG.PLAYER_COUNT; i++) {
            const x = this.platform.x - this.platform.width/2 + 100 + i * 120;
            const y = this.platform.y - this.platform.height/2 - 100;
            const player = new JellyPlayer(
              x, y, 
              COLORS.PLAYER_COLORS[i % COLORS.PLAYER_COLORS.length],
              i === 0
            );
            player.playerId = i === 0 ? 1 : 0;
            this.players.push(player);
          }
        }

        this.state = GameState.COUNTDOWN;
        this.countdown = CONFIG.COUNTDOWN_TIME;
        
        // å€’è®¡æ—¶
        const countdownInterval = setInterval(() => {
          soundManager.playCountdown();
          this.countdown--;
          if (this.countdown <= 0) {
            clearInterval(countdownInterval);
            this.state = GameState.PLAYING;
            this.timeLeft = CONFIG.ROUND_TIME;
          }
        }, 1000);
      }

      startNextLevel() {
        // ç»§ç»­ä¸‹ä¸€å…³ï¼Œä¸é‡ç½®å›åˆæ•°
        this.players = [];
        
        // é‡æ–°åˆå§‹åŒ–éšœç¢ç‰©ï¼ˆåº”ç”¨æ–°å…³å¡é…ç½®ï¼‰
        this.initObstacles();
        
        // åˆ›å»ºç©å®¶
        for (let i = 0; i < CONFIG.PLAYER_COUNT; i++) {
          const x = this.platform.x - this.platform.width/2 + 100 + i * 120;
          const y = this.platform.y - this.platform.height/2 - 100;
          const player = new JellyPlayer(
            x, y, 
            COLORS.PLAYER_COLORS[i % COLORS.PLAYER_COLORS.length],
            i === 0
          );
          this.players.push(player);
        }

        this.state = GameState.COUNTDOWN;
        this.countdown = CONFIG.COUNTDOWN_TIME;
        
        // å€’è®¡æ—¶
        const countdownInterval = setInterval(() => {
          soundManager.playCountdown();
          this.countdown--;
          if (this.countdown <= 0) {
            clearInterval(countdownInterval);
            this.state = GameState.PLAYING;
            this.timeLeft = CONFIG.ROUND_TIME;
          }
        }, 1000);
      }

      update(deltaTime) {
        if (this.state !== GameState.PLAYING) return;

        // æ›´æ–°æ—¶é—´
        this.timeLeft -= deltaTime / 1000;

        // æ›´æ–°ç©å®¶
        const alivePlayers = this.players.filter(p => p.isAlive);
        for (const player of this.players) {
          player.update(deltaTime, this.platform, this.obstacles, this.players);
        }

        // æ›´æ–°éšœç¢ç‰©
        for (const obstacle of this.obstacles) {
          obstacle.update(deltaTime);
        }
        
        // æ›´æ–°é“å…·
        for (const item of this.powerupItems) {
          item.update(deltaTime);
          if (!item.collected) {
            for (const player of this.players) {
              if (player.isAlive && player.playerId > 0) {
                item.checkCollision(player);
              }
            }
          }
        }

        // æ£€æŸ¥æ¸¸æˆç»“æŸæ¡ä»¶
        const playerAlive = this.players.filter(p => p.isAlive && p.playerId > 0).length;
        if (playerAlive === 0) {
          this.state = GameState.GAME_OVER;
          soundManager.playFall();
        } else if (alivePlayers.length === 1 && alivePlayers[0].playerId > 0) {
          if (this.round >= 10) {
            this.levelName = 'ğŸ‰ é€šå…³æˆåŠŸï¼';
          } else {
            this.round++;
          }
          this.state = GameState.ROUND_END;
          soundManager.playWin();
        } else if (this.timeLeft <= 0) {
          // æ—¶é—´åˆ°ï¼Œæ´»åˆ°æœ€åçš„ç©å®¶è·èƒœ
          const winner = this.players.filter(p => p.isAlive)[0];
          if (winner && winner.playerId > 0) {
            if (this.round >= 10) {
              this.levelName = 'ğŸ‰ é€šå…³æˆåŠŸï¼';
            } else {
              this.round++;
            }
            this.state = GameState.ROUND_END;
            soundManager.playWin();
          } else {
            this.state = GameState.GAME_OVER;
          }
        }

        // æ›´æ–°UI
        document.getElementById('count').textContent = 
          this.players.filter(p => p.isAlive).length;
        document.getElementById('round').textContent = this.round + ' - ' + this.levelName;
      }

      draw() {
        const ctx = this.ctx;
        
        // æ¸…ç©ºç”»å¸ƒ
        ctx.fillStyle = COLORS.BACKGROUND;
        ctx.fillRect(0, 0, CONFIG.LOGICAL_WIDTH, CONFIG.LOGICAL_HEIGHT);

        // ç»˜åˆ¶èƒŒæ™¯è£…é¥°
        this.drawBackground(ctx);

        // ç»˜åˆ¶å¹³å°
        this.drawPlatform(ctx);

        // ç»˜åˆ¶éšœç¢ç‰©
        for (const obstacle of this.obstacles) {
          obstacle.draw(ctx);
        }
        
        // ç»˜åˆ¶é“å…·
        for (const item of this.powerupItems) {
          item.draw(ctx);
        }

        // ç»˜åˆ¶ç©å®¶
        for (const player of this.players) {
          if (player.isAlive) {
            player.draw(ctx);
          }
        }

        // ç»˜åˆ¶UIè¦†ç›–å±‚
        this.drawUI(ctx);
      }

      drawBackground(ctx) {
        // æ¸å˜èƒŒæ™¯
        const gradient = ctx.createLinearGradient(0, 0, 0, CONFIG.LOGICAL_HEIGHT);
        gradient.addColorStop(0, '#1a1a2e');
        gradient.addColorStop(1, '#16213e');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, CONFIG.LOGICAL_WIDTH, CONFIG.LOGICAL_HEIGHT);

        // æ˜Ÿæ˜Ÿè£…é¥°
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        for (let i = 0; i < 50; i++) {
          const x = (i * 137) % CONFIG.LOGICAL_WIDTH;
          const y = (i * 89) % (CONFIG.LOGICAL_HEIGHT - 400);
          const size = (i % 3) + 1;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      drawPlatform(ctx) {
        const p = this.platform;
        
        // å¹³å°é˜´å½±
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(p.x - p.width/2 + 10, p.y - p.height/2 + 10, p.width, p.height);

        // å¹³å°ä¸»ä½“
        const gradient = ctx.createLinearGradient(p.x, p.y - p.height/2, p.x, p.y + p.height/2);
        gradient.addColorStop(0, COLORS.PLATFORM_EDGE);
        gradient.addColorStop(0.3, COLORS.PLATFORM);
        gradient.addColorStop(1, COLORS.PLATFORM_EDGE);
        
        ctx.fillStyle = gradient;
        ctx.fillRect(p.x - p.width/2, p.y - p.height/2, p.width, p.height);

        // å¹³å°è¾¹ç¼˜é«˜å…‰
        ctx.strokeStyle = '#8a8aaa';
        ctx.lineWidth = 4;
        ctx.strokeRect(p.x - p.width/2, p.y - p.height/2, p.width, p.height);

        // ç»ˆç‚¹çº¿
        const finishX = p.x + p.width/2 - 80;
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(finishX, p.y - p.height/2 - 20, 10, p.height + 20);
        
        // ç»ˆç‚¹æ¡çº¹
        for (let i = 0; i < 5; i++) {
          ctx.fillStyle = i % 2 === 0 ? '#000' : '#FFD700';
          ctx.fillRect(finishX + 10, p.y - p.height/2 + i * 40, 30, 20);
        }
      }

      drawUI(ctx) {
        ctx.fillStyle = COLORS.TEXT;
        ctx.textAlign = 'center';

        if (this.state === GameState.MENU) {
          // æ ‡é¢˜
          ctx.font = 'bold 80px "Microsoft YaHei", sans-serif';
          ctx.fillStyle = '#FFD700';
          ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
          ctx.shadowBlur = 10;
          ctx.fillText('ğŸ¬ ç³–è±†äºº', CONFIG.LOGICAL_WIDTH / 2, 350);
          
          ctx.font = 'bold 40px "Microsoft YaHei", sans-serif';
          ctx.fillStyle = '#fff';
          ctx.fillText('Jelly Man', CONFIG.LOGICAL_WIDTH / 2, 420);

          // å¼€å§‹æç¤º
          ctx.font = '30px "Microsoft YaHei", sans-serif';
          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.fillText('æŒ‰ä»»æ„é”®å¼€å§‹æ¸¸æˆ', CONFIG.LOGICAL_WIDTH / 2, 550);
          
          // æ¸¸æˆè¯´æ˜
          ctx.font = '24px "Microsoft YaHei", sans-serif';
          ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
          ctx.fillText('æ–¹å‘é”®/WASD ç§»åŠ¨ | ç©ºæ ¼ è·³è·ƒ', CONFIG.LOGICAL_WIDTH / 2, 620);
          ctx.fillText('èº²é¿éšœç¢ç‰©ï¼ŒåšæŒåˆ°æœ€åï¼', CONFIG.LOGICAL_WIDTH / 2, 660);

        } else if (this.state === GameState.COUNTDOWN) {
          ctx.font = 'bold 120px "Microsoft YaHei", sans-serif';
          ctx.fillStyle = '#FFD700';
          ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
          ctx.shadowBlur = 20;
          ctx.fillText(this.countdown.toString(), CONFIG.LOGICAL_WIDTH / 2, CONFIG.LOGICAL_HEIGHT / 2);

        } else if (this.state === GameState.PLAYING) {
          // è®¡æ—¶å™¨
          ctx.font = 'bold 40px "Microsoft YaHei", sans-serif';
          ctx.textAlign = 'right';
          ctx.fillStyle = this.timeLeft < 10 ? '#FF6B6B' : '#fff';
          ctx.shadowBlur = 5;
          ctx.fillText(`â± ${Math.ceil(this.timeLeft)}s`, CONFIG.LOGICAL_WIDTH - 50, 60);

        } else if (this.state === GameState.ROUND_END) {
          ctx.font = 'bold 60px "Microsoft YaHei", sans-serif';
          ctx.textAlign = 'center';
          ctx.fillStyle = '#FFD700';
          ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
          ctx.shadowBlur = 15;
          ctx.fillText('ğŸ† èƒœåˆ©ï¼', CONFIG.LOGICAL_WIDTH / 2, CONFIG.LOGICAL_HEIGHT / 2 - 30);
          
          ctx.font = '30px "Microsoft YaHei", sans-serif';
          ctx.fillStyle = '#fff';
          ctx.fillText('æŒ‰ä»»æ„é”®é‡æ–°å¼€å§‹', CONFIG.LOGICAL_WIDTH / 2, CONFIG.LOGICAL_HEIGHT / 2 + 40);

        } else if (this.state === GameState.GAME_OVER) {
          ctx.font = 'bold 60px "Microsoft YaHei", sans-serif';
          ctx.textAlign = 'center';
          ctx.fillStyle = '#FF6B6B';
          ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
          ctx.shadowBlur = 15;
          ctx.fillText('ğŸ’€ æ¸¸æˆç»“æŸ', CONFIG.LOGICAL_WIDTH / 2, CONFIG.LOGICAL_HEIGHT / 2 - 30);
          
          const aliveCount = this.players.filter(p => p.isAlive).length;
          ctx.font = '30px "Microsoft YaHei", sans-serif';
          ctx.fillStyle = '#fff';
          ctx.fillText(`å­˜æ´»ç©å®¶: ${aliveCount}`, CONFIG.LOGICAL_WIDTH / 2, CONFIG.LOGICAL_HEIGHT / 2 + 20);
          
          ctx.font = '24px "Microsoft YaHei", sans-serif';
          ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
          ctx.fillText('æŒ‰ä»»æ„é”®é‡æ–°å¼€å§‹', CONFIG.LOGICAL_WIDTH / 2, CONFIG.LOGICAL_HEIGHT / 2 + 70);
        }
      }

      gameLoop(timestamp) {
        const deltaTime = timestamp - this.lastTime;
        this.lastTime = timestamp;

        // é™åˆ¶æœ€å¤§deltaTimeé˜²æ­¢å¡é¡¿å¯¼è‡´çš„é—®é¢˜
        const clampedDelta = Math.min(deltaTime, 50);

        this.update(clampedDelta);
        this.draw();

        requestAnimationFrame((t) => this.gameLoop(t));
      }
    }

    // ==================== å¯åŠ¨æ¸¸æˆ ====================
    const soundManager = new SoundManager();
    let keys = {};
    
    // é¡µé¢åŠ è½½å®Œæˆåå¯åŠ¨æ¸¸æˆ
    window.addEventListener('load', () => {
      new Game();
    });
  </script>
</body>
</html>
