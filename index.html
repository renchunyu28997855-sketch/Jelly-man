<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ç³–è±†äºº - Jelly Man</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    #gameContainer {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #gameCanvas {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      border-radius: 8px;
      box-shadow: 0 0 40px rgba(0, 200, 255, 0.3);
    }

    #ui {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      font-size: 18px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      z-index: 10;
    }

    #soundToggle {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 16px;
      z-index: 10;
      transition: background 0.3s;
    }

    #soundToggle:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    #instructions {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.7);
      font-size: 14px;
      text-align: center;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
      <div id="playerCount">ç©å®¶: <span id="count">0</span></div>
      <div id="roundInfo">å›åˆ: <span id="round">1</span></div>
    </div>
    <button id="soundToggle">ğŸ”Š éŸ³æ•ˆ: å¼€</button>
    <div id="instructions">æ–¹å‘é”®/WASD ç§»åŠ¨ | ç©ºæ ¼ è·³è·ƒ</div>
  </div>

  <script>
    // ==================== å¸¸é‡é…ç½® ====================
    const CONFIG = {
      LOGICAL_WIDTH: 1920,
      LOGICAL_HEIGHT: 1080,
      PLAYER_COUNT: 12,
      PLAYER_RADIUS: 35,
      MOVE_SPEED: 8,
      JUMP_FORCE: -18,
      GRAVITY: 0.8,
      FRICTION: 0.88,
      BOUNCE: 0.4,
      PLATFORM_WIDTH: 1600,
      PLATFORM_HEIGHT: 200,
      OBSTACLE_COUNT: 5,
      ROUND_TIME: 60,
      COUNTDOWN_TIME: 3
    };

    const COLORS = {
      BACKGROUND: '#1a1a2e',
      PLATFORM: '#4a4a6a',
      PLATFORM_EDGE: '#6a6a8a',
      PLAYER_COLORS: [
        '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4',
        '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F',
        '#BB8FCE', '#85C1E9', '#F8B500', '#00CED1'
      ],
      TEXT: '#FFFFFF',
      TEXT_SHADOW: 'rgba(0, 0, 0, 0.5)'
    };

    const GameState = {
      MENU: 'menu',
      COUNTDOWN: 'countdown',
      PLAYING: 'playing',
      ROUND_END: 'round_end',
      GAME_OVER: 'game_over'
    };

    // ==================== éŸ³æ•ˆç³»ç»Ÿ ====================
    class SoundManager {
      constructor() {
        this.audioContext = null;
        this.enabled = true;
        this.initialized = false;
      }

      init() {
        if (this.initialized) return;
        try {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          this.initialized = true;
        } catch (e) {
          console.warn('Web Audio API ä¸æ”¯æŒ');
        }
      }

      playTone(frequency, duration, type = 'sine', volume = 0.3) {
        if (!this.enabled || !this.audioContext) return;
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.frequency.value = frequency;
        oscillator.type = type;
        
        gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
        
        oscillator.start();
        oscillator.stop(this.audioContext.currentTime + duration);
      }

      playJump() {
        this.playTone(400, 0.15, 'sine', 0.2);
        setTimeout(() => this.playTone(600, 0.1, 'sine', 0.15), 50);
      }

      playLand() {
        this.playTone(150, 0.1, 'triangle', 0.3);
      }

      playHit() {
        this.playTone(200, 0.15, 'square', 0.2);
      }

      playFall() {
        this.playTone(300, 0.3, 'sawtooth', 0.25);
        setTimeout(() => this.playTone(200, 0.3, 'sawtooth', 0.2), 150);
        setTimeout(() => this.playTone(100, 0.4, 'sawtooth', 0.15), 300);
      }

      playWin() {
        const notes = [523, 659, 784, 1047];
        notes.forEach((note, i) => {
          setTimeout(() => this.playTone(note, 0.3, 'sine', 0.25), i * 150);
        });
      }

      playCountdown() {
        this.playTone(880, 0.1, 'sine', 0.2);
      }

      playButton() {
        this.playTone(600, 0.08, 'sine', 0.15);
      }

      toggle() {
        this.enabled = !this.enabled;
        return this.enabled;
      }
    }

    // ==================== ç³–è±†äººç©å®¶ç±» ====================
    class JellyPlayer {
      constructor(x, y, color, isPlayer = false) {
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.color = color;
        this.radius = CONFIG.PLAYER_RADIUS;
        this.isPlayer = isPlayer;
        this.isAlive = true;
        this.wobble = Math.random() * Math.PI * 2;
        this.wobbleSpeed = 0.15;
        this.scaleX = 1;
        this.scaleY = 1;
        this.targetX = x;
        this.targetY = y;
        this.onGround = false;
        this.expression = 'normal';
      }

      update(deltaTime, platform, obstacles, players) {
        if (!this.isAlive) return;

        // æœå†»æ‘†åŠ¨åŠ¨ç”»
        this.wobble += this.wobbleSpeed * deltaTime;
        const wobbleAmount = 0.08;
        this.scaleX = 1 + Math.sin(this.wobble) * wobbleAmount;
        this.scaleY = 1 - Math.sin(this.wobble) * wobbleAmount;

        // å¦‚æœæ˜¯ç©å®¶ï¼Œå“åº”è¾“å…¥
        if (this.isPlayer) {
          this.handleInput();
        } else {
          // AI è¡Œä¸º
          this.handleAI(platform, obstacles, players);
        }

        // åº”ç”¨é‡åŠ›
        this.vy += CONFIG.GRAVITY;

        // åº”ç”¨æ‘©æ“¦åŠ›
        this.vx *= CONFIG.FRICTION;

        // æ›´æ–°ä½ç½®
        this.x += this.vx;
        this.y += this.vy;

        // å¹³å°ç¢°æ’
        this.handlePlatformCollision(platform);

        // éšœç¢ç‰©ç¢°æ’
        this.handleObstacleCollision(obstacles);

        // ç©å®¶é—´ç¢°æ’
        this.handlePlayerCollision(players);

        // æ›´æ–°è¡¨æƒ…
        this.updateExpression();

        // æ£€æŸ¥æ˜¯å¦æ‰å‡ºå¹³å°
        if (this.y > CONFIG.LOGICAL_HEIGHT + 100) {
          this.eliminate();
        }
      }

      handleInput() {
        if (keys.ArrowLeft || keys.KeyA) this.vx -= 1.2;
        if (keys.ArrowRight || keys.KeyD) this.vx += 1.2;
        if ((keys.Space || keys.ArrowUp || keys.KeyW) && this.onGround) {
          this.vy = CONFIG.JUMP_FORCE;
          this.onGround = false;
          soundManager.playJump();
        }

        // é™åˆ¶é€Ÿåº¦
        this.vx = Math.max(-CONFIG.MOVE_SPEED, Math.min(CONFIG.MOVE_SPEED, this.vx));
      }

      handleAI(platform, obstacles, players) {
        // ç®€å•çš„ AI è¡Œä¸º
        const alivePlayers = players.filter(p => p.isAlive);
        
        // å¯»æ‰¾ç›®æ ‡ä½ç½®
        if (Math.random() < 0.02) {
          // éšæœºç§»åŠ¨
          this.targetX = platform.x - platform.width/2 + Math.random() * platform.width;
          this.targetY = platform.y - platform.height/2 - 50;
        }

        // å‘ç›®æ ‡ç§»åŠ¨
        const dx = this.targetX - this.x;
        if (Math.abs(dx) > 20) {
          this.vx += dx > 0 ? 0.5 : -0.5;
        }

        // è·³è·ƒä»¥é¿å¼€éšœç¢ç‰©
        for (const obs of obstacles) {
          const dist = Math.hypot(this.x - obs.x, this.y - obs.y);
          if (dist < 150 && this.onGround) {
            this.vy = CONFIG.JUMP_FORCE;
            this.onGround = false;
          }
        }

        // é™åˆ¶é€Ÿåº¦
        this.vx = Math.max(-CONFIG.MOVE_SPEED * 0.7, Math.min(CONFIG.MOVE_SPEED * 0.7, this.vx));

        // éšæœºè·³è·ƒ
        if (this.onGround && Math.random() < 0.005) {
          this.vy = CONFIG.JUMP_FORCE;
          this.onGround = false;
        }
      }

      handlePlatformCollision(platform) {
        const platTop = platform.y - platform.height / 2;
        const platLeft = platform.x - platform.width / 2;
        const platRight = platform.x + platform.width / 2;

        // æ£€æµ‹æ˜¯å¦åœ¨å¹³å°èŒƒå›´å†…
        if (this.x > platLeft && this.x < platRight) {
          // ä»ä¸Šæ–¹è½ä¸‹
          if (this.y + this.radius > platTop && 
              this.y - this.radius < platTop + 20 &&
              this.vy > 0) {
            this.y = platTop - this.radius;
            if (this.vy > 5) {
              soundManager.playLand();
            }
            this.vy = -this.vy * CONFIG.BOUNCE;
            if (Math.abs(this.vy) < 2) {
              this.vy = 0;
              this.onGround = true;
            }
          }
        }
      }

      handleObstacleCollision(obstacles) {
        for (const obs of obstacles) {
          const dx = this.x - obs.x;
          const dy = this.y - obs.y;
          const dist = Math.hypot(dx, dy);
          const minDist = this.radius + obs.radius;

          if (dist < minDist) {
            // ç¢°æ’å“åº”
            const angle = Math.atan2(dy, dx);
            const pushForce = 8;
            this.vx += Math.cos(angle) * pushForce;
            this.vy += Math.sin(angle) * pushForce;
            soundManager.playHit();
          }
        }
      }

      handlePlayerCollision(players) {
        for (const other of players) {
          if (other === this || !other.isAlive) continue;

          const dx = this.x - other.x;
          const dy = this.y - other.y;
          const dist = Math.hypot(dx, dy);
          const minDist = this.radius + other.radius;

          if (dist < minDist && dist > 0) {
            // äº’ç›¸æ¨æŒ¤
            const overlap = minDist - dist;
            const angle = Math.atan2(dy, dx);
            const pushX = Math.cos(angle) * overlap * 0.5;
            const pushY = Math.sin(angle) * overlap * 0.5;

            this.x += pushX;
            this.y += pushY;
            other.x -= pushX;
            other.y -= pushY;

            // äº¤æ¢é€Ÿåº¦ï¼ˆå¼¹æ€§ç¢°æ’ï¼‰
            const tempVx = this.vx;
            const tempVy = this.vy;
            this.vx = other.vx * 0.8;
            this.vy = other.vy * 0.8;
            other.vx = tempVx * 0.8;
            other.vy = tempVy * 0.8;
          }
        }
      }

      updateExpression() {
        if (!this.isAlive) {
          this.expression = 'dead';
        } else if (Math.abs(this.vy) > 8) {
          this.expression = 'surprised';
        } else if (Math.abs(this.vx) > CONFIG.MOVE_SPEED * 0.8) {
          this.expression = 'excited';
        } else {
          this.expression = 'normal';
        }
      }

      eliminate() {
        this.isAlive = false;
        soundManager.playFall();
      }

      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.scaleX, this.scaleY);

        // ç»˜åˆ¶èº«ä½“ï¼ˆæœå†»å½¢çŠ¶ï¼‰
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        
        // æ¸å˜å¡«å……
        const gradient = ctx.createRadialGradient(
          -this.radius * 0.3, -this.radius * 0.3, 0,
          0, 0, this.radius
        );
        gradient.addColorStop(0, this.lightenColor(this.color, 40));
        gradient.addColorStop(0.7, this.color);
        gradient.addColorStop(1, this.darkenColor(this.color, 20));
        ctx.fillStyle = gradient;
        ctx.fill();

        // èº«ä½“è½®å»“
        ctx.strokeStyle = this.darkenColor(this.color, 30);
        ctx.lineWidth = 3;
        ctx.stroke();

        // ç»˜åˆ¶çœ¼ç›
        this.drawEyes(ctx);

        ctx.restore();
      }

      drawEyes(ctx) {
        const eyeOffsetX = 12;
        const eyeOffsetY = -5;
        const eyeRadius = 10;
        const pupilRadius = 5;

        // æ ¹æ®é€Ÿåº¦è®¡ç®—è§†çº¿åç§»
        let lookX = this.vx * 1.5;
        let lookY = this.vy * 0.5;

        if (this.expression === 'surprised') {
          lookY = -5;
        } else if (this.expression === 'excited') {
          lookX = this.vx > 0 ? 3 : -3;
        }

        // å·¦çœ¼
        ctx.beginPath();
        ctx.arc(-eyeOffsetX, eyeOffsetY, eyeRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.stroke();

        // å·¦ç³å­”
        ctx.beginPath();
        ctx.arc(-eyeOffsetX + lookX, eyeOffsetY + lookY, pupilRadius, 0, Math.PI * 2);
        ctx.fillStyle = '#333';
        ctx.fill();

        // å³çœ¼
        ctx.beginPath();
        ctx.arc(eyeOffsetX, eyeOffsetY, eyeRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.stroke();

        // å³ç³å­”
        ctx.beginPath();
        ctx.arc(eyeOffsetX + lookX, eyeOffsetY + lookY, pupilRadius, 0, Math.PI * 2);
        ctx.fillStyle = '#333';
        ctx.fill();

        // è¡¨æƒ…
        if (this.expression === 'surprised') {
          // æƒŠè®¶ - å¼ å¤§å˜´å·´
          ctx.beginPath();
          ctx.arc(0, 12, 8, 0, Math.PI * 2);
          ctx.fillStyle = '#FF6B6B';
          ctx.fill();
        } else if (this.expression === 'dead') {
          // æ­»äº¡ - X çœ¼ç›
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 2;
          
          // å·¦çœ¼ X
          ctx.beginPath();
          ctx.moveTo(-eyeOffsetX - 5, eyeOffsetY - 5);
          ctx.lineTo(-eyeOffsetX + 5, eyeOffsetY + 5);
          ctx.moveTo(-eyeOffsetX + 5, eyeOffsetY - 5);
          ctx.lineTo(-eyeOffsetX - 5, eyeOffsetY + 5);
          ctx.stroke();

          // å³çœ¼ X
          ctx.beginPath();
          ctx.moveTo(eyeOffsetX - 5, eyeOffsetY - 5);
          ctx.lineTo(eyeOffsetX + 5, eyeOffsetY + 5);
          ctx.moveTo(eyeOffsetX + 5, eyeOffsetY - 5);
          ctx.lineTo(eyeOffsetX - 5, eyeOffsetY + 5);
          ctx.stroke();
        }
      }

      lightenColor(color, percent) {
        const num = parseInt(color.replace('#', ''), 16);
        const amt = Math.round(2.55 * percent);
        const R = Math.min(255, (num >> 16) + amt);
        const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
        const B = Math.min(255, (num & 0x0000FF) + amt);
        return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
      }

      darkenColor(color, percent) {
        const num = parseInt(color.replace('#', ''), 16);
        const amt = Math.round(2.55 * percent);
        const R = Math.max(0, (num >> 16) - amt);
        const G = Math.max(0, ((num >> 8) & 0x00FF) - amt);
        const B = Math.max(0, (num & 0x0000FF) - amt);
        return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
      }
    }

    // ==================== éšœç¢ç‰©ç±» ====================
    class Obstacle {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.angle = 0;
        
        if (type === 'spinner') {
          this.radius = 60;
          this.rotationSpeed = 0.03;
        } else if (type === 'swing') {
          this.radius = 40;
          this.swingAngle = 0;
          this.swingSpeed = 0.05;
          this.swingAmplitude = 150;
        }
      }

      update(deltaTime) {
        if (this.type === 'spinner') {
          this.angle += this.rotationSpeed * deltaTime;
        } else if (this.type === 'swing') {
          this.swingAngle += this.swingSpeed * deltaTime;
          this.y = 450 + Math.sin(this.swingAngle) * this.swingAmplitude;
        }
      }

      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);

        if (this.type === 'spinner') {
          ctx.rotate(this.angle);
          
          // ç»˜åˆ¶æ—‹è½¬é£è½¦
          const armCount = 4;
          for (let i = 0; i < armCount; i++) {
            ctx.save();
            ctx.rotate((Math.PI * 2 / armCount) * i);
            
            // æ‰‹è‡‚
            ctx.fillStyle = '#FF6B6B';
            ctx.fillRect(-10, -this.radius, 20, this.radius * 1.5);
            
            // æœ«ç«¯çƒ
            ctx.beginPath();
            ctx.arc(0, -this.radius, 25, 0, Math.PI * 2);
            ctx.fillStyle = '#FF6B6B';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            ctx.restore();
          }

          // ä¸­å¿ƒ
          ctx.beginPath();
          ctx.arc(0, 0, 20, 0, Math.PI * 2);
          ctx.fillStyle = '#fff';
          ctx.fill();

        } else if (this.type === 'swing') {
          // ç»˜åˆ¶æ‘†åŠ¨çƒ
          ctx.beginPath();
          ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
          const gradient = ctx.createRadialGradient(-10, -10, 0, 0, 0, this.radius);
          gradient.addColorStop(0, '#FFE66D');
          gradient.addColorStop(1, '#F7B731');
          ctx.fillStyle = gradient;
          ctx.fill();
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 3;
          ctx.stroke();

          // ç»³å­
          ctx.beginPath();
          ctx.moveTo(0, -this.radius);
          ctx.lineTo(0, -this.y + 300);
          ctx.strokeStyle = '#888';
          ctx.lineWidth = 4;
          ctx.stroke();
        }

        ctx.restore();
      }
    }

    // ==================== æ¸¸æˆä¸»ç±» ====================
    class Game {
      constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.state = GameState.MENU;
        this.players = [];
        this.obstacles = [];
        this.platform = null;
        this.round = 1;
        this.timeLeft = CONFIG.ROUND_TIME;
        this.countdown = CONFIG.COUNTDOWN_TIME;
        this.lastTime = 0;
        
        this.initCanvas();
        this.initPlatform();
        this.initObstacles();
        this.initInput();
        
        // å¯åŠ¨æ¸¸æˆå¾ªç¯
        this.gameLoop(0);
      }

      initCanvas() {
        const dpr = window.devicePixelRatio || 1;
        this.canvas.width = CONFIG.LOGICAL_WIDTH * dpr;
        this.canvas.height = CONFIG.LOGICAL_HEIGHT * dpr;
        this.ctx.scale(dpr, dpr);
        this.canvas.style.width = CONFIG.LOGICAL_WIDTH + 'px';
        this.canvas.style.height = CONFIG.LOGICAL_HEIGHT + 'px';
      }

      initPlatform() {
        this.platform = {
          x: CONFIG.LOGICAL_WIDTH / 2,
          y: CONFIG.LOGICAL_HEIGHT - 200,
          width: CONFIG.PLATFORM_WIDTH,
          height: CONFIG.PLATFORM_HEIGHT
        };
      }

      initObstacles() {
        this.obstacles = [];
        
        // æ·»åŠ æ—‹è½¬é£è½¦
        for (let i = 0; i < 2; i++) {
          this.obstacles.push(new Obstacle(
            CONFIG.LOGICAL_WIDTH / 2 - 300 + i * 600,
            350,
            'spinner'
          ));
        }

        // æ·»åŠ æ‘†åŠ¨çƒ
        for (let i = 0; i < 3; i++) {
          this.obstacles.push(new Obstacle(
            CONFIG.LOGICAL_WIDTH / 2 - 200 + i * 200,
            450,
            'swing'
          ));
        }
      }

      initInput() {
        window.keys = {};
        
        window.addEventListener('keydown', (e) => {
          window.keys[e.code] = true;
          
          // åˆå§‹åŒ–éŸ³æ•ˆï¼ˆæµè§ˆå™¨ç­–ç•¥è¦æ±‚ç”¨æˆ·äº¤äº’ï¼‰
          soundManager.init();
          
          if (this.state === GameState.MENU || 
              this.state === GameState.GAME_OVER) {
            this.startGame();
          }
        });

        window.addEventListener('keyup', (e) => {
          window.keys[e.code] = false;
        });

        // éŸ³æ•ˆå¼€å…³
        document.getElementById('soundToggle').addEventListener('click', () => {
          soundManager.init();
          const enabled = soundManager.toggle();
          document.getElementById('soundToggle').textContent = 
            enabled ? 'ğŸ”Š éŸ³æ•ˆ: å¼€' : 'ğŸ”‡ éŸ³æ•ˆ: å…³';
          soundManager.playButton();
        });
      }

      startGame() {
        this.players = [];
        
        // åˆ›å»ºç©å®¶ï¼ˆç¬¬ä¸€ä¸ªæ˜¯äººç±»ç©å®¶ï¼‰
        for (let i = 0; i < CONFIG.PLAYER_COUNT; i++) {
          const x = this.platform.x - this.platform.width/2 + 100 + i * 120;
          const y = this.platform.y - this.platform.height/2 - 100;
          const player = new JellyPlayer(
            x, y, 
            COLORS.PLAYER_COLORS[i % COLORS.PLAYER_COLORS.length],
            i === 0
          );
          this.players.push(player);
        }

        this.state = GameState.COUNTDOWN;
        this.countdown = CONFIG.COUNTDOWN_TIME;
        
        // å€’è®¡æ—¶
        const countdownInterval = setInterval(() => {
          soundManager.playCountdown();
          this.countdown--;
          if (this.countdown <= 0) {
            clearInterval(countdownInterval);
            this.state = GameState.PLAYING;
            this.timeLeft = CONFIG.ROUND_TIME;
          }
        }, 1000);
      }

      update(deltaTime) {
        if (this.state !== GameState.PLAYING) return;

        // æ›´æ–°æ—¶é—´
        this.timeLeft -= deltaTime / 1000;

        // æ›´æ–°ç©å®¶
        const alivePlayers = this.players.filter(p => p.isAlive);
        for (const player of this.players) {
          player.update(deltaTime, this.platform, this.obstacles, this.players);
        }

        // æ›´æ–°éšœç¢ç‰©
        for (const obstacle of this.obstacles) {
          obstacle.update(deltaTime);
        }

        // æ£€æŸ¥æ¸¸æˆç»“æŸæ¡ä»¶
        const playerAlive = this.players.filter(p => p.isAlive && p.isPlayer).length;
        if (playerAlive === 0) {
          this.state = GameState.GAME_OVER;
          soundManager.playFall();
        } else if (alivePlayers.length === 1 && alivePlayers[0].isPlayer) {
          this.state = GameState.ROUND_END;
          soundManager.playWin();
        } else if (this.timeLeft <= 0) {
          // æ—¶é—´åˆ°ï¼Œæ´»åˆ°æœ€åçš„ç©å®¶è·èƒœ
          const winner = this.players.filter(p => p.isAlive)[0];
          if (winner && winner.isPlayer) {
            this.state = GameState.ROUND_END;
            soundManager.playWin();
          } else {
            this.state = GameState.GAME_OVER;
          }
        }

        // æ›´æ–°UI
        document.getElementById('count').textContent = 
          this.players.filter(p => p.isAlive).length;
        document.getElementById('round').textContent = this.round;
      }

      draw() {
        const ctx = this.ctx;
        
        // æ¸…ç©ºç”»å¸ƒ
        ctx.fillStyle = COLORS.BACKGROUND;
        ctx.fillRect(0, 0, CONFIG.LOGICAL_WIDTH, CONFIG.LOGICAL_HEIGHT);

        // ç»˜åˆ¶èƒŒæ™¯è£…é¥°
        this.drawBackground(ctx);

        // ç»˜åˆ¶å¹³å°
        this.drawPlatform(ctx);

        // ç»˜åˆ¶éšœç¢ç‰©
        for (const obstacle of this.obstacles) {
          obstacle.draw(ctx);
        }

        // ç»˜åˆ¶ç©å®¶
        for (const player of this.players) {
          if (player.isAlive) {
            player.draw(ctx);
          }
        }

        // ç»˜åˆ¶UIè¦†ç›–å±‚
        this.drawUI(ctx);
      }

      drawBackground(ctx) {
        // æ¸å˜èƒŒæ™¯
        const gradient = ctx.createLinearGradient(0, 0, 0, CONFIG.LOGICAL_HEIGHT);
        gradient.addColorStop(0, '#1a1a2e');
        gradient.addColorStop(1, '#16213e');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, CONFIG.LOGICAL_WIDTH, CONFIG.LOGICAL_HEIGHT);

        // æ˜Ÿæ˜Ÿè£…é¥°
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        for (let i = 0; i < 50; i++) {
          const x = (i * 137) % CONFIG.LOGICAL_WIDTH;
          const y = (i * 89) % (CONFIG.LOGICAL_HEIGHT - 400);
          const size = (i % 3) + 1;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      drawPlatform(ctx) {
        const p = this.platform;
        
        // å¹³å°é˜´å½±
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(p.x - p.width/2 + 10, p.y - p.height/2 + 10, p.width, p.height);

        // å¹³å°ä¸»ä½“
        const gradient = ctx.createLinearGradient(p.x, p.y - p.height/2, p.x, p.y + p.height/2);
        gradient.addColorStop(0, COLORS.PLATFORM_EDGE);
        gradient.addColorStop(0.3, COLORS.PLATFORM);
        gradient.addColorStop(1, COLORS.PLATFORM_EDGE);
        
        ctx.fillStyle = gradient;
        ctx.fillRect(p.x - p.width/2, p.y - p.height/2, p.width, p.height);

        // å¹³å°è¾¹ç¼˜é«˜å…‰
        ctx.strokeStyle = '#8a8aaa';
        ctx.lineWidth = 4;
        ctx.strokeRect(p.x - p.width/2, p.y - p.height/2, p.width, p.height);

        // ç»ˆç‚¹çº¿
        const finishX = p.x + p.width/2 - 80;
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(finishX, p.y - p.height/2 - 20, 10, p.height + 20);
        
        // ç»ˆç‚¹æ¡çº¹
        for (let i = 0; i < 5; i++) {
          ctx.fillStyle = i % 2 === 0 ? '#000' : '#FFD700';
          ctx.fillRect(finishX + 10, p.y - p.height/2 + i * 40, 30, 20);
        }
      }

      drawUI(ctx) {
        ctx.fillStyle = COLORS.TEXT;
        ctx.textAlign = 'center';

        if (this.state === GameState.MENU) {
          // æ ‡é¢˜
          ctx.font = 'bold 80px "Microsoft YaHei", sans-serif';
          ctx.fillStyle = '#FFD700';
          ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
          ctx.shadowBlur = 10;
          ctx.fillText('ğŸ¬ ç³–è±†äºº', CONFIG.LOGICAL_WIDTH / 2, 350);
          
          ctx.font = 'bold 40px "Microsoft YaHei", sans-serif';
          ctx.fillStyle = '#fff';
          ctx.fillText('Jelly Man', CONFIG.LOGICAL_WIDTH / 2, 420);

          // å¼€å§‹æç¤º
          ctx.font = '30px "Microsoft YaHei", sans-serif';
          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.fillText('æŒ‰ä»»æ„é”®å¼€å§‹æ¸¸æˆ', CONFIG.LOGICAL_WIDTH / 2, 550);
          
          // æ¸¸æˆè¯´æ˜
          ctx.font = '24px "Microsoft YaHei", sans-serif';
          ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
          ctx.fillText('æ–¹å‘é”®/WASD ç§»åŠ¨ | ç©ºæ ¼ è·³è·ƒ', CONFIG.LOGICAL_WIDTH / 2, 620);
          ctx.fillText('èº²é¿éšœç¢ç‰©ï¼ŒåšæŒåˆ°æœ€åï¼', CONFIG.LOGICAL_WIDTH / 2, 660);

        } else if (this.state === GameState.COUNTDOWN) {
          ctx.font = 'bold 120px "Microsoft YaHei", sans-serif';
          ctx.fillStyle = '#FFD700';
          ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
          ctx.shadowBlur = 20;
          ctx.fillText(this.countdown.toString(), CONFIG.LOGICAL_WIDTH / 2, CONFIG.LOGICAL_HEIGHT / 2);

        } else if (this.state === GameState.PLAYING) {
          // è®¡æ—¶å™¨
          ctx.font = 'bold 40px "Microsoft YaHei", sans-serif';
          ctx.textAlign = 'right';
          ctx.fillStyle = this.timeLeft < 10 ? '#FF6B6B' : '#fff';
          ctx.shadowBlur = 5;
          ctx.fillText(`â± ${Math.ceil(this.timeLeft)}s`, CONFIG.LOGICAL_WIDTH - 50, 60);

        } else if (this.state === GameState.ROUND_END) {
          ctx.font = 'bold 60px "Microsoft YaHei", sans-serif';
          ctx.textAlign = 'center';
          ctx.fillStyle = '#FFD700';
          ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
          ctx.shadowBlur = 15;
          ctx.fillText('ğŸ† èƒœåˆ©ï¼', CONFIG.LOGICAL_WIDTH / 2, CONFIG.LOGICAL_HEIGHT / 2 - 30);
          
          ctx.font = '30px "Microsoft YaHei", sans-serif';
          ctx.fillStyle = '#fff';
          ctx.fillText('æŒ‰ä»»æ„é”®é‡æ–°å¼€å§‹', CONFIG.LOGICAL_WIDTH / 2, CONFIG.LOGICAL_HEIGHT / 2 + 40);

        } else if (this.state === GameState.GAME_OVER) {
          ctx.font = 'bold 60px "Microsoft YaHei", sans-serif';
          ctx.textAlign = 'center';
          ctx.fillStyle = '#FF6B6B';
          ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
          ctx.shadowBlur = 15;
          ctx.fillText('ğŸ’€ æ¸¸æˆç»“æŸ', CONFIG.LOGICAL_WIDTH / 2, CONFIG.LOGICAL_HEIGHT / 2 - 30);
          
          const aliveCount = this.players.filter(p => p.isAlive).length;
          ctx.font = '30px "Microsoft YaHei", sans-serif';
          ctx.fillStyle = '#fff';
          ctx.fillText(`å­˜æ´»ç©å®¶: ${aliveCount}`, CONFIG.LOGICAL_WIDTH / 2, CONFIG.LOGICAL_HEIGHT / 2 + 20);
          
          ctx.font = '24px "Microsoft YaHei", sans-serif';
          ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
          ctx.fillText('æŒ‰ä»»æ„é”®é‡æ–°å¼€å§‹', CONFIG.LOGICAL_WIDTH / 2, CONFIG.LOGICAL_HEIGHT / 2 + 70);
        }
      }

      gameLoop(timestamp) {
        const deltaTime = timestamp - this.lastTime;
        this.lastTime = timestamp;

        // é™åˆ¶æœ€å¤§deltaTimeé˜²æ­¢å¡é¡¿å¯¼è‡´çš„é—®é¢˜
        const clampedDelta = Math.min(deltaTime, 50);

        this.update(clampedDelta);
        this.draw();

        requestAnimationFrame((t) => this.gameLoop(t));
      }
    }

    // ==================== å¯åŠ¨æ¸¸æˆ ====================
    const soundManager = new SoundManager();
    let keys = {};
    
    // é¡µé¢åŠ è½½å®Œæˆåå¯åŠ¨æ¸¸æˆ
    window.addEventListener('load', () => {
      new Game();
    });
  </script>
</body>
</html>
